/**
 * Узел бинарного дерева поиска
 */
class TreeNode {
  constructor(value) {
    // Сохраняем значение узла
    // Ссылка на левое поддерево
    // Ссылка на правое поддерево
  }
}

/**
 * Бинарное дерево поиска
 * Поддерживает операции вставки, поиска, удаления, обхода
 */
class BinarySearchTree {
  // корень дерева
  // количество узлов

  /**
   * Вставляет новое значение в дерево
   */
  insert(value) {
    // 1. Сравнить текущий размер дерева
    // 2. Вызвать рекурсивную вставку начиная с корня
    // 3. Если размер увеличился — значит узел был вставлен
  }

  /**
   * Рекурсивная вставка узла
   */
  #insertNode(node, value) {
    // 1. Если текущая позиция пустая — создать новый узел
    // 2. Если значение меньше текущего узла — рекурсивно вставить влево
    // 3. Если значение больше текущего узла — рекурсивно вставить вправо
    // 4. Если равно — ничего не делать (дубликаты запрещены)
    // 5. Вернуть узел
  }

  /**
   * Поиск значения в дереве
   */
  search(value) {
    // 1. Вызвать рекурсивный поиск начиная с корня
    // 2. Вернуть найденный узел или null
  }

  /**
   * Рекурсивный поиск узла
   */
  #searchNode(node, value) {
    // 1. Если текущая позиция пустая — вернуть null
    // 2. Если значение совпало — вернуть узел
    // 3. Если значение меньше — рекурсивно искать слева
    // 4. Если значение больше — рекурсивно искать справа
  }

  /**
   * Проверка: содержится ли значение в дереве
   */
  contains(value) {
    // 1. Вызвать метод поиска
    // 2. Проверить, что результат не равен null
  }

  /**
   * Находит минимальное значение в дереве
   */
  findMin() {
    // 1. Если дерево пустое — вернуть null
    // 2. Двигаться от корня всё время влево
    // 3. Вернуть найденный узел
  }

  /**
   * Находит максимальное значение в дереве
   */
  findMax() {
    // 1. Если дерево пустое — вернуть null
    // 2. Двигаться от корня всё время вправо
    // 3. Вернуть найденный узел
  }

  /**
   * Удаляет значение из дерева
   */
  remove(value) {
    // 1. Сохранить текущий размер
    // 2. Вызвать рекурсивное удаление начиная с корня
    // 3. Если размер уменьшился — значит удаление прошло успешно
  }

  /**
   * Рекурсивное удаление узла
   */
  #removeNode(node, value) {
    // 1. Если текущий узел пустой — вернуть null
    // 2. Если значение меньше — рекурсивно удалять влево
    // 3. Если значение больше — рекурсивно удалять вправо
    // 4. Если совпало — обработать три случая:
    //    а) узел без детей → вернуть null
    //    б) узел с одним ребёнком → вернуть ребёнка
    //    в) узел с двумя детьми → найти минимальный в правом поддереве,
    //       заменить значение и удалить преемника
    // 5. Вернуть обновлённый узел
  }

  /**
   * Возвращает количество узлов
   */
  get size() {
    // вернуть значение счётчика узлов
  }

  /**
   * Проверяет, пустое ли дерево
   */
  get isEmpty() {
    // вернуть true если корень пустой
  }

  /**
   * Обход in-order (слева — корень — справа)
   */
  inOrder() {
    // 1. Создать пустой массив
    // 2. Вызвать рекурсивный обход начиная с корня
    // 3. Вернуть массив
  }

  /**
   * Обход pre-order (корень — слева — справа)
   */
  preOrder() {
    // 1. Создать пустой массив
    // 2. Вызвать рекурсивный обход начиная с корня
    // 3. Вернуть массив
  }

  /**
   * Обход post-order (слева — справа — корень)
   */
  postOrder() {
    // 1. Создать пустой массив
    // 2. Вызвать рекурсивный обход начиная с корня
    // 3. Вернуть массив
  }

  /**
   * Рекурсивный обход in-order
   */
  #inOrderTraversal(node, result) {
    // 1. Если узел пустой — завершить
    // 2. Рекурсивно обойти левое поддерево
    // 3. Добавить значение текущего узла
    // 4. Рекурсивно обойти правое поддерево
  }

  /**
   * Рекурсивный обход pre-order
   */
  #preOrderTraversal(node, result) {
    // 1. Если узел пустой — завершить
    // 2. Добавить значение текущего узла
    // 3. Рекурсивно обойти левое поддерево
    // 4. Рекурсивно обойти правое поддерево
  }

  /**
   * Рекурсивный обход post-order
   */
  #postOrderTraversal(node, result) {
    // 1. Если узел пустой — завершить
    // 2. Рекурсивно обойти левое поддерево
    // 3. Рекурсивно обойти правое поддерево
    // 4. Добавить значение текущего узла
  }

  /**
   * Вычисляет высоту дерева
   */
  getHeight() {
    // 1. Вызвать рекурсивный метод от корня
    // 2. Вернуть полученное значение
  }

  /**
   * Рекурсивное вычисление высоты
   */
  #calculateHeight(node) {
    // 1. Если узел пустой — вернуть 0
    // 2. Рекурсивно вычислить высоту левого поддерева
    // 3. Рекурсивно вычислить высоту правого поддерева
    // 4. Вернуть максимум из двух + 1
  }

  /**
   * Проверяет, является ли дерево корректным BST
   */
  isValidBST() {
    // 1. Вызвать рекурсивную проверку начиная с корня
    // 2. Передать минимальное и максимальное возможные значения
  }

  /**
   * Рекурсивная проверка валидности BST
   */
  #validateBST(node, min, max) {
    // 1. Если узел пустой — вернуть true
    // 2. Если значение нарушает диапазон — вернуть false
    // 3. Проверить левое поддерево с обновлённым максимумом
    // 4. Проверить правое поддерево с обновлённым минимумом
    // 5. Вернуть результат логического "И"
  }

  /**
   * Очищает дерево
   */
  clear() {
    // 1. Обнулить корень
    // 2. Сбросить размер до 0
  }

  /**
   * Возвращает строковое представление дерева
   */
  toString() {
    // 1. Получить отсортированный массив значений через in-order
    // 2. Вернуть строку с размером и этими значениями
  }

}
